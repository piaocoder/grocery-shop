---
title: 并发和并行  
date:  2016-09-05 22:00:00  
tags: c  
---


欢迎来到狂想的个人实验室。  
github：[unlessbamboo](https://github.com/unlessbamboo)


### 1 Introduction
> 关于并发和并行，需看完资料后再次整理，目前仅仅做社会主义初级阶段记录
> 《深入浅出DPDK》 《现代操作系统》
- process and thread——使用场景、使用优劣
- kernel thread——用户线程和内核线程
- multiple kernel——多核编程和单核编程的区别
- 软件优化层次


### 2 Process and thread
#### 2.1 多进程
- 弱相关的处理，即单一进程的死亡不会影响到其他进程，例如chrome的插件;
- 扩展到多机分布的程序；
- IO，看实际情况，线程更好
#### 2.2 多线程
- 频繁的创建和销毁
- 计算密集型和IO密集型在单核上的区别
- 强相关的处理场景
#### 2.3 优劣
- 数据共享：多进程使用复杂的IPC，但是多线程涉及数据同步问题
- 编程调试：数据同步等问题导致调试困难
- CPU利用率：大部分场景，多进程低于多线程


### 3 kernel thread
#### 3.1 kernel
具体参见《现代操作系统》和《程序员自我修养》
- 内核线程是CPU调度的基本单位，LWP
- 内核某一个线程的阻塞不会影响其他内核线程
#### 3.2 User
- 用户线程对内核透明，由程序员来控制内核切换，可控性
- 用户线程只能在同一进程内争夺资源
- 用户线程不能高效的利用多核，并发和并行的区别，多核中一般使用内核
- 同一进程在任意时刻只能有一个用户线程运行，分时复用
#### 3.3 调度区别
- 用户线程执行系统调用时，导致所属进程整体中断
- 内核线程执行系统调用时，导致该线程被中断


### 4 Mul-core
#### 4.1 锁竞争
饥饿致死——某一个特定线程无法得到CPU时间，一直阻塞等待。  
在多核编程中，如果两个线程使用同一把锁会导致此类问题，不能完美的利用
多核硬件。
#### 4.2 负载均衡
在多核编程中，尽可能保证每一个CPU的计算量一致。
#### 4.3 伪内存
多个硬件线程使用了同一个cache缓存，出现数据混合。
#### 4.4 串行和并行
串行——单核
并行运算——并行设计模式+并行算法
分布式运算——负载均衡，解决CPU饥饿


### 5 软件优化层次
- 系统层面优化（内存/cpu/进程数量/IO各项数值的判定）
- 应用层面优化（算法/并行设计）
- 微架构层面（微处理体系）
某一种设计方案并不能适用于所有场景，考虑带宽/数据竞争等。
