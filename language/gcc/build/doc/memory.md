---
C内存管理
---


### 1 Introduction
#### 1.1 C存储类
C语言中的存储类定义。
#### 1.2 内存布局
每一个进程的VMA布局以及一些术语。
- 基本概念
- 进程的虚拟内存布局
#### 1.3 内存知识
地址空间提出的原因？如何管理空闲的内存地址？
虚拟内存提出的原因？页面置换算法都有那些？
分页系统中的知识点？分页和分段？


### 2 Storage Class
> 内存管理——通过决定哪些函数了解哪些变量在程序中的存活时间来控制
#### 2.1 Glossary
##### 2.1.1 定义
- 存储时期——变量在内存中保留的时间
- 作用域——程序中可以访问一个标识符的一个或者多个区域
- 链接——变量在代码块/文件之间的可见性
##### 2.1.2 Scope
- 代码块作用域——函数中的任何变量定义
- 函数原型作用域——函数原型中声明的任何变量，其实无意义
- 文件作用域——所有函数之外的变量定义/函数声明
- 函数作用域——仅仅用于goto语句，在整个函数内部，随便跳转
##### 2.1.3 Link
- 外部链接——外部存储类（extern storage class），变量（external variable）
- 内部链接——具有内部链接的static变量（external static）
- 空链接——代码块中的变量

##### 2.1.4 Lifetime
- 静态存储时期——在程序执行期间一直存在
- 自动存储时期——跟随代码块的消亡而释放

#### 2.2 Consociation
##### 2.2.1 存储类
```gcc
    存储类      时期        作用域      链接        声明方式
    --------------------------------------------------------------------
    auto        自动存储    代码块      空连接      代码块内
    register    自动存储    代码块      空链接      代码块内
    static:
                静态        文件        外部链接    所有函数之外的声明
                静态        代码块      空链接      在代码块内的static
                静态        文件        内部链接    所有函数之外的static
    ---------------------------------------------------------------------
```
##### 2.2.2 存储类说明符
- auto——代码块作用域内的自动存储
- register——代码块作用域内的自动存储
- static——见上面说明
- extern——表明在声明一个“已经在别处定义了的变量”
- typedef——与内存无关，仅仅因为语法而被归类，见typedef.md文件
extern的额外说明：
```
    extern在文件作用域中声明，则所指向的变量必然具有外部链接（源变量所在地）
    extern在代码块作用域中声明，则所指向的变量可能具有外部链接或者内部链接
```
##### 2.2.3 类型限定词
const：常量限定词，定义时初始化
volatile(易变的)：
```
    原因：
        方便编译器优化，即让某些聪明的程序员家长亲自教育编译器，从而高效的成长
    使用：
        限定为volatile，该变量允许除程序之外的其他代理改变
```
restrict(限制)：
```
    原因：类似restrict
    使用：
        将某个变量（指针）限定为某一个内存中的唯一初始的访问方式，即不存在
        另个指针变量访问同一个restrict内存
```
##### 2.2.4 存储类+限定词
```gcc
    a,类型+变量，例如int A
    b,存储类+类型+变量，多个存储类不同同时存在
        typedef int IN;
        // 下面用法错误，而且也解释不通
        typedef static int INT;
    c,限定词+类型+变量，其中限定词可以多个
        const volatile int i;
```


### 3 Memory Layout
#### 3.1 基本概念
##### 3.1.1 堆和栈
堆是动态分配，栈静态分配。  
堆动态分配和动态释放的内存，程序运行期间不会自动释放。  
栈的效率远远高于堆, 编译器自动分配/释放该内存
##### 3.1.2 分页和分段
paging-将地址空间人为的等分为固定大小的页，伴随VAS的产生而产生。
segmentation-二维概念，社会精细化分工，不同的端拥有不同的信息和功能。
##### 3.1.3 术语
MMU
```
    内存管理部件，实现虚拟地址到物理地址的转变，见《Linking》
    18页/《Modern op》107页。
```
VMA
```
    虚拟内存地址
```
VAS
```
    虚拟内存空间，对物理内存的抽象，类似进程对CPU的抽象
```
页映射
```
    通过MMU来实现虚拟地址到物理地址的映射，时刻在变化
```
脏页
```
    内存中某一页数据发生改动，此时必须将数据写回磁盘才能删除。
```
缺页中断
```
    映射虚拟内存地址时，无法找到相应的物理地址，从而产生中断，
    更新映射表。
```
#### 3.2 布局
```
    -----------------------
         kernel space
    -----------------------
            stack
    -----------------------
            ...
    -----------------------
       dynamic libraries
    -----------------------
            ...
    -----------------------
            heap
    -----------------------
          .data .bss
    -----------------------
           readonly
    -----------------------
           reserved
    -----------------------
```
上图请结合ELF文件格式来了解，具体见《Linking》中说明。


### 4 内存知识
##### 4.1 地址空间原由
###### 4.1.1 无存储器抽象缺点
- 人为破坏操作系统
- 难以运行多用户程序
- 软件编写过于繁杂
###### 4.1.2 地址空间
地址空间是一种内存抽象，为了“保护”和“重定向”而产生，是一个进程
可用于寻址内存的一套地址集合。  

##### 4.2 地址空间管理
程序中存在很多动态内存分配，必须对空间内存有一定的管理机制：  
- 位图存储管理
- 链表存储管理

##### 4.3 虚拟内存原由
###### 4.3.1 原因
单系统上的所有程序使用内存总和超过实际物理内存，从而产生了：  
- 覆盖交换技术
- 虚拟内存
###### 4.3.2 虚拟内存
vimtual memory：每一个进程都有自己的地址空间，空间被分割成多个块，每一块成为paging，每一页都是连续的地址范围。
> 关于分页/分段这里不再描述。  

##### 4.4 页面置换算法
- 最优算法
- NRU算法（最近未使用）
- FIFO算法
- 第二次机会算法（将未使用页面放入链表尾部，给予改过自新机会）
- 时钟算法（所有页面保存在类似时钟的链表中）
- LRU算法（最近最少使用）
- NFU算法（最不经常使用）
- 其他

##### 4.5 分页系统
负载控制--保证内存负载，避免系统颠簸
页面大小--小页面不会产生过多内存碎片，但是产生巨大的页面，反之
共享库的装载--使用写时复制，为每一个使用某一个库的页面的进程创建新的页面，参见position-independent code
内存映射文件--共享库其实是内存映射文件(mmap)的一个特例

##### 4.6 paging and segmentation
- 分页是一维的，虚地址从0到最大，一个接连一个，反之
- 分段是社会精细化分工，不断的段有不同的职责，见ELF格式
- 分段和分页结合使用。
